// -*- c-basic-offset: 4; tab-width: 8; indent-tabs-mode: t -*-
#include "compositequeue.h"
#include <math.h>

#include <climits>
#include <iostream>
#include <sstream>

#include "dynexp_topology.h"

extern uint32_t delay_host2ToR; // nanoseconds, host-to-tor link
extern uint32_t delay_ToR2ToR; // nanoseconds, tor-to-tor link

// !!! NOTE: this one does selective RLB packet dropping.

// !!! NOTE: this has been modified to also include a lower priority RLB queue

#define TRIM_RATIO 5
#define SEND_RATIO 5

CompositeQueue::CompositeQueue(linkspeed_bps bitrate, mem_b maxsize, EventList& eventlist,
			       QueueLogger* logger, int tor, int port)
  : Queue(bitrate, maxsize, eventlist, logger), _hop_delay_forward(HopDelayForward(eventlist))
{
  _tor = tor;
  _port = port;
  // original version:
  //_ratio_high = 10; // number of headers to send per data packet (originally 24 for Jan '18 version)
  //_ratio_low = 1; // number of full packets
  // new version:
  _ratio_high = 640 * _shortflow_bound; // bytes (640 = 10 64B headers)
  _ratio_low = 1500; // bytes (1500 = 1 1500B packet)
	_ratio_high_prime = 640 * _longflow_bound; // bytes (640 = 10 64B headers)
  _ratio_low_prime = 1500; // bytes (1500 = 1 1500B packet)
  _crt = 0;
  _num_headers = 0;
  _num_packets = 0;
  _num_acks = 0;
  _num_nacks = 0;
  _num_pulls = 0;
  _num_drops = 0;
  _num_stripped = 0;
  _num_bounced = 0;

  _crt_send_ratio_high = 0;
  _crt_send_ratio_low = 0;
  _crt_trim_ratio = 0;

  _queuesize_high = _queuesize_low = _queuesize_high_prime = _queuesize_low_prime = 0;
  _serv = QUEUE_INVALID;

}

void CompositeQueue::beginService(){
    assert(_serv == QUEUE_INVALID);
    Packet* sent_pkt = NULL;
    bool sent_succeed = false;
    //at least one high prio queue and one low prio queue have to send
    if ( (!_enqueued_high.empty() || !_enqueued_high_prime.empty()) && (!_enqueued_low.empty() || !_enqueued_low_prime.empty())){
        if (_crt >= (_ratio_high+_ratio_low))
            _crt = 0;
        //high prio turn
        if (_crt< _ratio_high) {
            //both queues have a packet, choose which to send by highprio send ratio
            if (!_enqueued_high.empty() && !_enqueued_high_prime.empty()){
                if (_crt_send_ratio_high < SEND_RATIO){
                    assert(!_enqueued_high.empty());
                    _serv = QUEUE_HIGH;
                    //raise send ratio
                    _crt_send_ratio_high++;
                } else {
                    assert(!_enqueued_high_prime.empty());
                    _serv = QUEUE_HIGH_PRIME;
                    //reset send ratio
                    _crt_send_ratio_high = 0;
                }
                //only short flow high prio has to send
            } else if (!_enqueued_high.empty()){
                _serv = QUEUE_HIGH;
                //only long flow high prio has to send
            } else {
                _serv = QUEUE_HIGH_PRIME;
            }
            //update high/low prio send ratio
            _crt += 64; //hard coded header size
                        //low prio turn
        } else {
            assert(_crt < _ratio_high+_ratio_low);
            int sz;
            //both queues have a packet, choose which to send by lowprio send ratio
            if (!_enqueued_low.empty() && !_enqueued_low_prime.empty()){
                if (_crt_send_ratio_low < SEND_RATIO){
                    assert(!_enqueued_low.empty());
                    _serv = QUEUE_LOW;
                    sz = _enqueued_low.back()->size();
                    _crt_send_ratio_low++;
                } else {
                    assert(!_enqueued_low_prime.empty());
                    _serv = QUEUE_LOW_PRIME;
                    sz = _enqueued_low_prime.back()->size();
                    _crt_send_ratio_low = 0;
                }
                //only short flow low prio has to send
            } else if (!_enqueued_low.empty()){
                _serv = QUEUE_LOW;
                sz = _enqueued_low.back()->size();
                //only long flow low prio has to send
            } else {
                _serv = QUEUE_LOW_PRIME;
                sz = _enqueued_low_prime.back()->size();
            }
            //update low/low prio send ratio
            _crt += sz; //hard coded header size
        }
        //only high prio and high prio prime have to send
    } else if (!_enqueued_high.empty() && !_enqueued_high_prime.empty()){
        if (_crt_send_ratio_high < SEND_RATIO){
            assert(!_enqueued_high.empty());
            _serv = QUEUE_HIGH;
            _crt_send_ratio_high++;
        } else {
            assert(!_enqueued_high_prime.empty());
            _serv = QUEUE_HIGH_PRIME;
            _crt_send_ratio_high = 0;
        }
        //only low prio and low prio prime have to send
    } else if (!_enqueued_low.empty() && !_enqueued_low_prime.empty()){
        if (_crt_send_ratio_low < SEND_RATIO){
            _serv = QUEUE_LOW;
            _crt_send_ratio_low++;
        } else {
            assert(!_enqueued_low_prime.empty());
            _serv = QUEUE_LOW_PRIME;
            _crt_send_ratio_low = 0;
        } 
        //only one queue has to send
    } else {
        if (!_enqueued_high.empty()) {
            _serv = QUEUE_HIGH;
        } else if (!_enqueued_low.empty()) {
            _serv = QUEUE_LOW;
        } else if (!_enqueued_high_prime.empty()) {
            _serv = QUEUE_HIGH_PRIME;
        } else if (!_enqueued_low_prime.empty()) {
            _serv = QUEUE_LOW_PRIME;
        } else {
            assert(0);
            _serv = QUEUE_INVALID;
        }
    }
    switch(_serv){
        case QUEUE_HIGH:
        {
            sent_pkt = _enqueued_high.back();
            int scheduled_port = sent_pkt->get_crtport();
            simtime_picosec sent_time = _hop_delay_forward.routing(sent_pkt, eventlist().now());
            if (sent_pkt->get_topology()->is_downlink(_port)){
                eventlist().sourceIsPendingRel(*this, drainTime(sent_pkt));
                sent_succeed = true;
            }else if (sent_pkt->get_crtport() == scheduled_port) {
                eventlist().sourceIsPending(*this, sent_time);
                sent_succeed = true;
            } else {
                _queuesize_high -= sent_pkt->size();
                _enqueued_high.pop_back();
            }
            break;
        }
        case QUEUE_LOW:
        {
            sent_pkt = _enqueued_low.back();
            int scheduled_port = sent_pkt->get_crtport();
            simtime_picosec sent_time = _hop_delay_forward.routing(sent_pkt, eventlist().now());
            if (sent_pkt->get_topology()->is_downlink(_port)){
                eventlist().sourceIsPendingRel(*this, drainTime(sent_pkt));
                sent_succeed = true;
            }else if (sent_pkt->get_crtport() == scheduled_port) {
                eventlist().sourceIsPending(*this, sent_time);
                sent_succeed = true;
            } else {
                _queuesize_low -= sent_pkt->size();
                _enqueued_low.pop_back();
            }
            break;
        }
        case QUEUE_HIGH_PRIME:
        {
            sent_pkt = _enqueued_high_prime.back();
            int scheduled_port = sent_pkt->get_crtport();
            simtime_picosec sent_time = _hop_delay_forward.routing(sent_pkt, eventlist().now());
            if (sent_pkt->get_topology()->is_downlink(_port)){
                eventlist().sourceIsPendingRel(*this, drainTime(sent_pkt));
                sent_succeed = true;
            }else if (sent_pkt->get_crtport() == scheduled_port) {
                eventlist().sourceIsPending(*this, sent_time);
                sent_succeed = true;
            } else {
                _queuesize_high_prime -= sent_pkt->size();
                _enqueued_high_prime.pop_back();
            }
            break;
        }
        case QUEUE_LOW_PRIME:
        {
            sent_pkt = _enqueued_low_prime.back();
            int scheduled_port = sent_pkt->get_crtport();
            simtime_picosec sent_time = _hop_delay_forward.routing(sent_pkt, eventlist().now());
            if (sent_pkt->get_topology()->is_downlink(_port)){
                eventlist().sourceIsPendingRel(*this, drainTime(sent_pkt));
                sent_succeed = true;
            }else if (sent_pkt->get_crtport() == scheduled_port) {
                eventlist().sourceIsPending(*this, sent_time);
                sent_succeed = true;
            } else {
                _queuesize_low_prime -= sent_pkt->size();
                _enqueued_low_prime.pop_back();
            }
            break;
        }
        default:
            assert(0);
    }

    // No silent failures allowed with no RTO
    if(!sent_succeed){
        if (sent_pkt->header_only()){
            if(sent_pkt->bounced())
                sent_pkt->free();
            else
                _hop_delay_forward.bouncePkt(sent_pkt);
        } else {
            sent_pkt->strip_payload();
            receivePacket(*sent_pkt);
        }
        _serv = QUEUE_INVALID;
    }

    if (!sent_succeed && queuesize() > 0) {
        beginService();
    }
}

void CompositeQueue::completeService() {
    Packet* pkt;

    uint64_t new_NDP_bytes_sent;

    bool sendingpkt = true;

    if (_serv == QUEUE_LOW) {
        assert(!_enqueued_low.empty());
        pkt = _enqueued_low.back();
        _enqueued_low.pop_back();
        _queuesize_low -= pkt->size();
        _num_packets++;
    } else if (_serv == QUEUE_HIGH) {
        assert(!_enqueued_high.empty());
        pkt = _enqueued_high.back();
        _enqueued_high.pop_back();
        _queuesize_high -= pkt->size();
        if (pkt->type() == NDPACK)
            _num_acks++;
        else if (pkt->type() == NDPNACK)
            _num_nacks++;
        else if (pkt->type() == NDPPULL)
            _num_pulls++;
        else {
            _num_headers++;
        }
    } else if (_serv == QUEUE_LOW_PRIME) {
        //assert(!_enqueued_low_prime.empty());
        // race! low_prime packet got removed before completion :(
        if (_enqueued_low_prime.empty()){
            _serv = QUEUE_INVALID;
            return beginService();
        }
        pkt = _enqueued_low_prime.back();
        _enqueued_low_prime.pop_back();
        _queuesize_low_prime -= pkt->size();
        _num_packets++;
    } else if (_serv == QUEUE_HIGH_PRIME) {
        assert(!_enqueued_high_prime.empty());
        pkt = _enqueued_high_prime.back();
        _enqueued_high_prime.pop_back();
        _queuesize_high_prime -= pkt->size();
        if (pkt->type() == NDPACK)
            _num_acks++;
        else if (pkt->type() == NDPNACK)
            _num_nacks++;
        else if (pkt->type() == NDPPULL)
            _num_pulls++;
        else {
            _num_headers++;
        }
    } else {
        assert(0);
    }

    //cout << "sending pkt from tor " << eventlist().now() << " (tor,port) " << _tor << "," << _port << endl;
    if (sendingpkt)
        sendFromQueue(pkt);

    _serv = QUEUE_INVALID;

    if (!_enqueued_high.empty() || !_enqueued_low.empty() || !_enqueued_high_prime.empty() || !_enqueued_low_prime.empty())
        beginService();
}

void CompositeQueue::doNextEvent() {
	completeService();
}

#if 1
void CompositeQueue::receivePacket(Packet& _pkt) {
    Packet* pkt = &_pkt;
    Packet* booted_pkt = NULL;
    bool packet_added = false;
    if (!pkt->get_longflow()) {
        bool drop_long = false;
        if (!pkt->header_only()){
            if (total_qsize() + pkt->size() <= _maxsize || (_queuesize_low_prime > 0 && _crt_trim_ratio < TRIM_RATIO && (drop_long=true))
                    || (drand()<0.5 && !_enqueued_low.empty())) {
                //regular packet; don't drop the arriving packet
                // we are here because either the queue isn't full or,
                // it might be full and we randomly chose an
                // enqueued packet to trim from long queue or own queue

                bool chk = true;

                //there is a packet to trime
                if (total_qsize() + pkt->size() > _maxsize) {
                    //it is a packet from the long queue
                    if (drop_long){
                        booted_pkt = _enqueued_low_prime.front();
                    } else {
                        //take last packet from low prio queue, make it a header and place it in the high prio queue
                        booted_pkt = _enqueued_low.front();
                    }
                    // added a check to make sure that the booted packet makes enough space in the queue
                    // for the incoming packet
                    if (booted_pkt->size() >= pkt->size()) {

                        chk = true;

                        if (drop_long){
                            cout << "Dropping LONG for SHORT packet" << endl;
                            _enqueued_low_prime.pop_front();
                            _queuesize_low_prime -= booted_pkt->size();
                        } else {
                            _enqueued_low.pop_front();
                            _queuesize_low -= booted_pkt->size();
                        }

                        booted_pkt->strip_payload();
                        _num_stripped++;
                        booted_pkt->flow().logTraffic(*booted_pkt,*this,TrafficLogger::PKT_TRIM);
                        if (_logger)
                            _logger->logQueue(*this, QueueLogger::PKT_TRIM, *pkt);

                    } else {
                        chk = false;
                        booted_pkt = NULL;
                    }
                }

                if (chk) {
                    // the new packet fit
                    assert(total_qsize() + pkt->size() <= _maxsize);
                    _enqueued_low.push_front(pkt);
                    _queuesize_low += pkt->size();
                    packet_added = true;
                } else {
                    // the packet wouldn't fit if we booted the existing packet
                    pkt->strip_payload();
                    _num_stripped++;
                }

            } else {
                //strip payload on the arriving packet - low priority queue is full
                pkt->strip_payload();
                _num_stripped++;

            }
        }

        //if a packet was booted, it is now a header to be enqueued in high prio
        if (booted_pkt != NULL){
            pkt = booted_pkt;
        }

        if (pkt->header_only() && !pkt->get_longflow()){
            if (_queuesize_high + pkt->size() > _maxsize){
                if (pkt->bounced() == false) {
                    _hop_delay_forward.bouncePkt(pkt);
		    		_num_bounced++;
                } else {

                    // debug:
                    cout << "   ... this is an RTS packet. Dropped.\n";
                    //if (_logger) _logger->logQueue(*this, QueueLogger::PKT_DROP, pkt);
                    //pkt->flow().logTraffic(pkt,*this,TrafficLogger::PKT_DROP);

                    pkt->free();
                    _num_drops++;
                }
            } else {
                _enqueued_high.push_front(pkt);
                _queuesize_high += pkt->size();
                packet_added = true;
            }
        }
    }
    if (pkt->get_longflow()){
        //cout << "receive time " << eventlist().now() << " (tor,port) " << _tor << "," << _port << endl;
        if (!pkt->header_only()){
            if (total_qsize() + pkt->size() <= _maxsize || (drand()<0.5 && !_enqueued_low_prime.empty())) {
                //regular packet; don't drop the arriving packet

                // we are here because either the queue isn't full or,
                // it might be full and we randomly chose an
                // enqueued packet to trim

                bool chk = true;

                if (total_qsize() + pkt->size() > _maxsize) {
                    // we're going to drop an existing packet from the queue
                    if (_enqueued_low_prime.empty()){
                        //cout << "QUeuesize " << _queuesize_low << " packetsize " << pkt->size() << " maxsize " << _maxsize << endl;
                        assert(0);
                    }
                    //static int dropped_total;
                    //cout << "dropped total " << ++dropped_total << " time " << eventlist().now() << " (tor,port) " << _tor << "," << _port << endl;
                    //take last packet from low prio queue, make it a header and place it in the high prio queue

                    booted_pkt = _enqueued_low_prime.front();

                    // added a check to make sure that the booted packet makes enough space in the queue
                    // for the incoming packet
                    if (booted_pkt->size() >= pkt->size()) {

                        chk = true;

                        _enqueued_low_prime.pop_front();
                        _queuesize_low_prime -= booted_pkt->size();

                        booted_pkt->strip_payload();
                        _num_stripped++;
                        booted_pkt->flow().logTraffic(*booted_pkt,*this,TrafficLogger::PKT_TRIM);
                        if (_logger)
                            _logger->logQueue(*this, QueueLogger::PKT_TRIM, *pkt);
                    } else {
                        chk = false;
                        booted_pkt = NULL;
                    }
                }

                if (chk) {
                    // the new packet fit
                    assert(total_qsize() + pkt->size() <= _maxsize);
                    _enqueued_low_prime.push_front(pkt);
                    _queuesize_low_prime += pkt->size();
                    packet_added = true;
                } else {
                    // the packet wouldn't fit if we booted the existing packet
                    pkt->strip_payload();
                    _num_stripped++;
                }

            } else {
                //strip payload on the arriving packet - low priority queue is full
                pkt->strip_payload();
                _num_stripped++;
            }
        }

        //if a packet was booted, it is now a header to be enqueued in high prio
        if (booted_pkt != NULL){
            pkt = booted_pkt;
        }

        if (pkt->header_only()) {
            if (_queuesize_high_prime + pkt->size() > _maxsize){
                if (pkt->bounced() == false) {
                    _hop_delay_forward.bouncePkt(pkt);
		    		_num_bounced++;
                } else {

                    // debug:
                    cout << "   ... this is an RTS packet. Dropped.\n";
                    //if (_logger) _logger->logQueue(*this, QueueLogger::PKT_DROP, pkt);
                    //pkt->flow().logTraffic(pkt,*this,TrafficLogger::PKT_DROP);

                    pkt->free();
                    _num_drops++;
                }
            } else {
                _enqueued_high_prime.push_front(pkt);
                _queuesize_high_prime += pkt->size();
                packet_added = true;
            }
        }
    }

    if (_serv == QUEUE_INVALID && packet_added) {
        beginService();
    }
}
#endif

mem_b CompositeQueue::queuesize() {
    return _queuesize_low + _queuesize_high + _queuesize_low_prime + _queuesize_high;
}

HopDelayForward::HopDelayForward(EventList &eventlist)
	: EventSource(eventlist, "HopDelayForward") {}

void HopDelayForward::insertBouncedQ(simtime_picosec t, Packet* pkt) {
	pair<simtime_picosec, Packet*> item = make_pair(t, pkt);
	// YX: TODO: change to binary search with comparator
	bool inserted = false;
	for (int i = 0; i < _bounced_pkts.size(); i++) {
		if (_bounced_pkts[i].first <= item.first) {
			_bounced_pkts.insert(_bounced_pkts.begin()+i, item);
			inserted = true;
			break;
		}
	}
	if (!inserted) {
		_bounced_pkts.push_back(item);
	}
}

void HopDelayForward::bouncePkt(Packet* pkt) {
	DynExpTopology* top = pkt->get_topology();
	pkt->bounce(); // indicate that the packet has been bounced

	// flip the source and dst of the packet:
	int s = pkt->get_src();
	int d = pkt->get_dst();
	pkt->set_src(d);
	pkt->set_dst(s);

	// get the current ToR, this will be the new src_ToR of the packet
	int new_src_ToR = pkt->get_crtToR();

	if (new_src_ToR == pkt->get_src_ToR()) {
		// the packet got returned at the source ToR
		// we need to send on a downlink right away
		pkt->set_src_ToR(new_src_ToR);
		pkt->set_crtport(top->get_lastport(pkt->get_dst()));
		pkt->set_maxhops(0);
		pkt->set_crthop(0);
		pkt->set_crtToR(new_src_ToR);

		Queue* nextqueue = top->get_queue_tor(pkt->get_crtToR(), pkt->get_crtport());
		nextqueue->receivePacket(*pkt);
		// debug:
		//cout << "   packet RTSed at the first ToR (ToR = " << new_src_ToR << ")" << endl;

	} else {
		pkt->set_src_ToR(new_src_ToR);
		// YX: Can be removed, need double check
		pkt->set_path_index(0); // set which path the packet will take
		// YX: no need to set a limit to # max hops, need double check.
		pkt->set_maxhops(INT_MAX);

		simtime_picosec sent_time = routing(pkt, eventlist().now());
		insertBouncedQ(sent_time, pkt);
		eventlist().sourceIsPending(*this, sent_time);
	}
}

void HopDelayForward::doNextEvent() {
	pair<simtime_picosec, Packet*> to_sent = _bounced_pkts.back();
	assert(to_sent.first == eventlist().now());
	Packet* pkt = to_sent.second;
	DynExpTopology* top = pkt->get_topology();
	Queue* nextqueue = top->get_queue_tor(pkt->get_crtToR(), pkt->get_crtport());
	nextqueue->receivePacket(*pkt);
	_bounced_pkts.pop_back();
}

simtime_picosec HopDelayForward::routing(Packet* pkt, simtime_picosec t) {
	DynExpTopology* top = pkt->get_topology();
	int slice = top->time_to_slice(t);

	pair<int, int> route;
	if (pkt->get_longflow()) {
		// YX: get_crtToR() should give you the first ToR only, please test
        //cout << "direct routing between " << pkt->get_crtToR() << " & " << top->get_firstToR(pkt->get_dst()) << endl;
		route = top->get_direct_routing(pkt->get_crtToR(), top->get_firstToR(pkt->get_dst()), slice);
	} else {
		route = top->get_routing(pkt->get_crtToR(), top->get_firstToR(pkt->get_dst()), slice);
	}


	int uplink = route.first;
	int sent_slice = route.second;

    // if this is the last ToR, need to get downlink port
    if(pkt->get_crtToR() == top->get_firstToR(pkt->get_dst())){
        pkt->set_crtport(top->get_lastport(pkt->get_dst()));
    } else {
        //FD uplink never seems to get changed so I just put this here
	    pkt->set_crtport(uplink);
    }
    //cout << "hop " << pkt->get_crthop() << " crtToR " << pkt->get_crtToR() << " port " << pkt->get_crtport() << endl;
    Queue* q = top->get_queue_tor(pkt->get_crtToR(), uplink);
    CompositeQueue *cq = dynamic_cast<CompositeQueue*>(q);

    if (sent_slice == slice) {
        // YX: TODO: calculate delay considering the queue occupancy, same below
        int finish_slice = top->time_to_slice(t + cq->drainTime(pkt)
                + timeFromNs(delay_ToR2ToR)); // plus the link delay

		if (finish_slice == slice) {
			return (t + cq->drainTime(pkt));
		}
		// May wrap around the cycle
		int slice_delta = (finish_slice - slice + top->get_nsuperslice() * 2)
			% (top->get_nsuperslice() * 2);

        if (slice_delta == 1) {
            if (top->get_nextToR(slice, pkt->get_crtToR(), uplink) ==
                    top->get_nextToR(finish_slice, pkt->get_crtToR(), uplink)) {
                return (t + cq->drainTime(pkt));
            }
            // Miss this slice, have to wait till the next slice
            int next_absolute_slice = top->time_to_absolute_slice(t) + 1;
            simtime_picosec next_time = top->get_slice_start_time(next_absolute_slice);
            return routing(pkt, next_time);
        }

        assert(slice_delta == 2); // Cannot be more than 2!

        int middle_slice = (slice + 1) % (top->get_nsuperslice() * 2);

		int next_tor1 = top->get_nextToR(slice, pkt->get_crtToR(), uplink);
		int next_tor2 = top->get_nextToR(middle_slice, pkt->get_crtToR(), uplink);
		int next_tor3 = top->get_nextToR(finish_slice, pkt->get_crtToR(), uplink);

		if ((next_tor1 == next_tor2) && (next_tor2 == next_tor3)) {
			return (t + cq->drainTime(pkt));
		}
		// Miss this slice, have to wait till the next slice
		int next_absolute_slice = top->time_to_absolute_slice(t) + 1;
		simtime_picosec next_time = top->get_slice_start_time(next_absolute_slice);
		return routing(pkt, next_time);
	} else {
		// Send at the beginning of the sent_slice
		int wait_slice = (sent_slice - slice + top->get_nsuperslice() * 2)
			% (top->get_nsuperslice() * 2);
		int sent_absolute_slice = top->time_to_absolute_slice(t) + wait_slice;
		return (top->get_slice_start_time(sent_absolute_slice) +
			cq->drainTime(pkt));
	}
}
